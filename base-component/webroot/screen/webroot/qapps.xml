<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<screen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/xml-screen-3.xsd"
        require-authentication="false" screen-theme-type-enum-id="STT_INTERNAL_QUASAR" default-menu-title="Applications" allow-extra-path="true">
    <!-- NOTE: require-authentication=false so no permission required but in pre-actions if no user logged in goes to login screen -->

    <pre-actions><script><![CDATA[
        // 纯JWT认证系统 - 完全符合用户"只能用jwt这套东西"要求

        // Check if accessing marketplace Chat
        def currentPath = sri.getScreenUrlInfo().getFullPathNameList().join("/")
        def isMarketplaceChat = currentPath?.contains("marketplace/Chat")

        // 纯JWT认证：优先使用现有session，其次验证JWT
        def isAuthenticated = ec.user.userId ? true : false

        def authHeader = ec.web.getRequest().getHeader('Authorization')
        def jwtToken = null

        if (authHeader?.startsWith('Bearer ')) {
            jwtToken = authHeader.substring(7)  // Remove "Bearer " prefix
        } else {
            // 检查cookie中的JWT token
            def jwtCookie = ec.web.getRequest().getCookies()?.find { it.name == 'jwt_access_token' }
            if (jwtCookie?.value?.startsWith('eyJ')) {  // JWT format check
                jwtToken = jwtCookie.value
            }
        }

        if (jwtToken) {
            logger.debug("JWT认证：检测到token，length=${jwtToken.length()}, session userId=${ec.user.userId}")
            try {
                // 基础JWT验证：检查格式和过期时间
                def parts = jwtToken.split('\\.')
                if (parts.length == 3) {
                    def payload = new String(java.util.Base64.getDecoder().decode(parts[1]))
                    def payloadJson = new groovy.json.JsonSlurper().parseText(payload)

                    def now = System.currentTimeMillis() / 1000
                    if (payloadJson.exp && payloadJson.exp > now) {
                        def userId = payloadJson.userId ?: payloadJson.sub
                        logger.debug("JWT认证：解析payload userId=${userId}, exp=${payloadJson.exp}, now=${now}")
                        if (userId && userId.length() > 0) {
                            try {
                                if (ec.user.userId != userId) {
                                    def userAccount = ec.entity.find("moqui.security.UserAccount")
                                            .condition("userId", userId)
                                            .disableAuthz()
                                            .one()
                                    if (userAccount?.username) {
                                        logger.debug("JWT认证：internalLoginUser(${userAccount.username})")
                                        ec.user.internalLoginUser(userAccount.username)
                                    } else {
                                        throw new IllegalStateException("无法根据userId ${userId} 找到有效的UserAccount")
                                    }
                                }
                                isAuthenticated = true
                                logger.info("纯JWT认证成功: ${userId}")
                            } catch (Exception loginEx) {
                                logger.warn("JWT用户登录失败: ${loginEx.message}", loginEx)
                            }
                        }
                    } else {
                        logger.warn("JWT token已过期 exp=${payloadJson.exp} now=${now}")
                    }
                } else {
                    logger.warn("JWT token结构不正确，parts=${parts.length}")
                }
            } catch (Exception e) {
                logger.warn("JWT验证异常: ${e.message}", e)
            }
        } else if (!isAuthenticated) {
            logger.debug("JWT认证：未检测到token, session userId=${ec.user.userId}")
        }

        // 开发调试：强制跳过认证检查用于测试
        def skipAuth = (ec.web.getRequest().getParameter('skipAuth') == 'true')

        logger.debug("JWT认证：结果 isAuthenticated=${isAuthenticated}, isMarketplaceChat=${isMarketplaceChat}, skipAuth=${skipAuth}, currentPath=${currentPath}, session userId=${ec.user.userId}")

        // if authentication failed and not marketplace Chat, redirect to Login
        if (!isAuthenticated && !isMarketplaceChat && !skipAuth) {
            logger.info("JWT认证：未通过，重定向至 /Login (path=${currentPath})")
            ec.web.saveScreenLastInfo(null, null);
            sri.sendRedirectAndStopRender('/Login')
        }

        html_scripts.add('/libs/moment.js/moment-with-locales.min.js')
        html_scripts.add('/libs/jquery/jquery.min.js')
        html_scripts.add('/includes/JwtAuth.js')

        // For marketplace Chat, pre-load the styles and LiveChat script
        if (isMarketplaceChat) {
            // Add marketplace chat specific styles without Bootstrap dependencies
            html_stylesheets.add('/css/marketplace-chat.css')

            // Add LiveChat and marketplace chat scripts to footer
            footer_scripts.add('http://localhost:4000/livechat/rocketchat-livechat.min.js')
            footer_scripts.add('/js/marketplace-chat-livechat.js')
        }

        String instancePurpose = System.getProperty("instance_purpose")
        String quasarCss = sri.buildUrl('/libs/quasar2/quasar.min.css').url
        if (!html_stylesheets.contains(quasarCss)) html_stylesheets.add(quasarCss)
                if (!instancePurpose || instancePurpose == 'production') {
            /* ========== Production Mode - Vue 3.x + Quasar 2.x ========== */
            html_scripts.add('/js/MoquiLib.min.js')
            footer_scripts.add('/libs/vue3/vue.min.js')
            footer_scripts.add('/libs/quasar2/quasar.umd.min.js')
            footer_scripts.add('/js/WebrootVue.qvt.js')
        } else {
            /* ========== Dev Mode - Vue 3.x + Quasar 2.x ========== */
            html_scripts.add('/js/MoquiLib.js')
            footer_scripts.add('/libs/vue3/vue.js')
            footer_scripts.add('/libs/quasar2/quasar.umd.js')
            footer_scripts.add('/js/WebrootVue.qvt.js')
        }

        // conditional QZ Tray scripts, only include if enabled
        if (ec.user.getPreference("qz.print.enabled") == "true") {
            footer_scripts.add('/js/qz-tray/sha-256.min.js')
            footer_scripts.add('/js/qz-tray/qz-tray.min.js')
            // TODO migrate MoquiQzComponent.js to MoquiQzComponent.qvt.js
            footer_scripts.add('/js/qz-tray/MoquiQzComponent.js')
        }
    ]]></script></pre-actions>

    <transition name="setPreference">
        <actions><script>
            // 检查用户是否已登录
            if (!ec.user.userId) {
                ec.web.response.sendError(401, "User not logged in")
                return
            }

            // 检查参数
            if (!preferenceKey) {
                ec.web.response.sendError(400, "preferenceKey is required")
                return
            }

            try {
                ec.user.setPreference(preferenceKey, preferenceValue)
            } catch (Exception e) {
                logger.error("setPreference failed for key ${preferenceKey}", e)
                ec.web.response.sendError(500, "Failed to set preference: " + e.message)
            }
        </script></actions>
        <default-response type="none"/>
    </transition>

    <transition name="qzSign">
        <parameter name="message"/>
        <actions><script>
            import org.moqui.context.ExecutionContext
            ExecutionContext ec = context.ec
            ec.web.response.setContentType("text/plain")
            ec.web.response.writer.write("---...---")
        </script></actions>
        <default-response type="none"/>
    </transition>

    <transition name="getPreferences">
        <actions><script>
            import groovy.json.JsonBuilder
            def preferences = [:]
            preferences["qz.printer.main.active"] = ec.user.getPreference("qz.printer.main.active") ?: ""
            preferences["qz.printer.label.active"] = ec.user.getPreference("qz.printer.label.active") ?: ""
            ec.web.response.setContentType("application/json")
            ec.web.response.writer.write(new JsonBuilder(preferences).toString())
        </script></actions>
        <default-response type="none"/>
    </transition>

    <transition name="menuData" read-only="true" begin-transaction="false">
        <actions><script><![CDATA[
            // Enhanced menuData transition with Menu Registry Service integration
            // Phase 2 Implementation: Replace sri.getMenuData() with decoupled menu service

            List menuDataList = []
            boolean useFallback = false
            String fallbackReason = ""

            try {
                // Step 1: Try to get menu data from Menu Registry Service
                Map registryResult = null
                try {
                    registryResult = ec.service.sync().name("get", "MenuData")
                        .parameters([
                            categoryId: ec.web.parameters.categoryId,
                            parentId: ec.web.parameters.parentId,
                            flatten: true,  // 返回扁平列表用于导航
                            includePermissions: true
                        ]).call()
                } catch (Exception serviceEx) {
                    ec.logger.warn("Menu Registry Service call failed: ${serviceEx.message}")
                    // 服务不可用时不抛异常，继续使用fallback
                }

                // Step 2: Process Menu Registry Service result
                if (registryResult?.success && registryResult.menuData) {
                    menuDataList.addAll(registryResult.menuData)
                    ec.logger.info("Menu loaded from Registry Service successfully (${menuDataList.size()} items)")
                } else {
                    // Step 3: Fallback to traditional sri.getMenuData() with error boundary
                    useFallback = true
                    fallbackReason = "Registry service unavailable or returned no data"

                    try {
                        // Enhanced fallback logic with error boundary
                        def fallbackLogic = evaluate('file:component://webroot/script/menu-fallback-logic.groovy')
                        if (fallbackLogic) {
                            Map fallbackResult = fallbackLogic.handleMenuFailure(ec, fallbackReason, "SERVICE_UNAVAILABLE")
                            if (fallbackResult?.success && fallbackResult.menuDataList) {
                                menuDataList.addAll(fallbackResult.menuDataList)
                                ec.logger.info("Menu loaded from fallback mechanism (${menuDataList.size()} items)")
                            }
                        } else {
                            throw new Exception("Fallback logic script not available")
                        }

                    } catch (Exception fallbackEx) {
                        // Final fallback: Traditional method with try-catch
                        fallbackReason = "Both registry service and fallback failed: ${fallbackEx.message}"
                        ec.logger.warn("Using traditional menu loading: ${fallbackReason}")

                        try {
                            // Traditional screen-based menu generation (with error boundary)
                            List<String> targetPathList = null
                            String screenPathParam = ec.web.parameters.screenPath
                            if (screenPathParam) {
                                targetPathList = screenPathParam.split('/')*.trim().findAll { it }
                            }
                            if (!targetPathList || targetPathList.isEmpty()) {
                                targetPathList = sri.screenUrlInfo.extraPathNameList
                            }

                            List standardMenuList = sri.getMenuData(targetPathList)
                            if (standardMenuList != null) {
                                menuDataList.addAll(standardMenuList)
                                ec.logger.info("Menu loaded from traditional method (${menuDataList.size()} items)")
                            }

                        } catch (Exception traditionalEx) {
                            // Ultimate fallback: Emergency menu
                            ec.logger.error("All menu loading methods failed, using emergency menu: ${traditionalEx.message}")
                            menuDataList = getEmergencyMenu()
                            useFallback = true
                            fallbackReason = "Emergency mode: ${traditionalEx.message}"
                        }
                    }
                }

                // Step 4: Always ensure "返回主页" link is at the top
                def homeLink = [
                    title: "返回主页",
                    url: "/qapps/AppList",
                    image: "fa fa-home",
                    imageType: "icon",
                    priority: 0  // Highest priority
                ]

                // Remove any existing home links to avoid duplicates
                menuDataList = menuDataList.findAll { !(it.url == "/qapps/AppList" || it.title == "返回主页") }

                // Add home link at the top
                menuDataList.add(0, homeLink)

                // Step 5: Add metadata for monitoring and debugging
                def responseData = [
                    menuData: menuDataList,
                    metadata: [
                        source: useFallback ? "fallback" : "registry",
                        fallbackReason: fallbackReason,
                        itemCount: menuDataList.size(),
                        timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'"),
                        version: "2.0-decoupled"
                    ]
                ]

                // Step 6: Cache successful results for fallback use
                if (!useFallback && menuDataList.size() > 0) {
                    try {
                        ec.cache.put("MenuRegistry", "LastKnownGood", menuDataList, 3600) // 1 hour cache
                    } catch (Exception cacheEx) {
                        ec.logger.warn("Failed to cache menu data: ${cacheEx.message}")
                    }
                }

                ec.web.sendJsonResponse(responseData)

            } catch (Exception e) {
                // Critical error handling: Return emergency response
                ec.logger.error("Critical error in menuData transition: ${e.message}", e)

                def emergencyResponse = [
                    menuData: getEmergencyMenu(),
                    metadata: [
                        source: "emergency",
                        fallbackReason: "Critical error: ${e.message}",
                        itemCount: 3,
                        timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'"),
                        version: "2.0-emergency"
                    ]
                ]

                ec.web.sendJsonResponse(emergencyResponse)
            }

            // Helper method: Get emergency menu (always available)
            def getEmergencyMenu() {
                return [
                    [title: "返回首页", url: "/qapps/AppList", image: "fa fa-home", imageType: "icon"],
                    [title: "系统帮助", url: "/qapps/help", image: "fa fa-question-circle", imageType: "icon"],
                    [title: "安全退出", url: "/Login/logout", image: "fa fa-sign-out-alt", imageType: "icon"]
                ]
            }
        ]]></script></actions>
        <default-response type="none" save-parameters="true"/>
    </transition>

    <subscreens default-item="AppList">
        <subscreens-item name="AppList" location="component://webroot/screen/webroot/apps/AppList.xml"/>
        <subscreens-item name="tools" menu-title="工具" location="component://tools/screen/Tools.xml"/>
        <subscreens-item name="system" menu-title="系统" location="component://tools/screen/System.xml"/>
        <subscreens-item name="simple" menu-title="Simple Screens" location="component://SimpleScreens/screen/SimpleScreens.xml"/>
        <subscreens-item name="marketplace" menu-title="供需匹配" location="component://moqui-marketplace/screen/marketplace.xml"/>
        <subscreens-item name="mcp" menu-title="MCP控制台" menu-image="fa fa-robot" location="component://moqui-mcp/screen/mcp.xml"/>
        <subscreens-item name="minio" menu-title="对象存储" location="component://moqui-minio/screen/MinioApp.xml"/>
        <subscreens-item name="hivemind" menu-title="智慧蜂巢" menu-image="fa fa-check" location="component://HiveMind/screen/HiveMindRoot.xml"/>
        <subscreens-item name="hmadmin" menu-title="Hive Mind Admin" location="component://HiveMind/screen/HiveMindAdmin.xml"/>
        <subscreens-item name="popc" menu-title="电商ERP" menu-image="fa fa-shopping-cart" location="component://PopCommerce/screen/PopCommerceAdmin.xml"/>
        <subscreens-item name="marble" menu-title="Marble ERP" menu-image="fa fa-cogs" location="component://MarbleERP/screen/marble.xml"/>
    </subscreens>

    <widgets>
        <render-mode>
            <!-- for html just render the navbar (Vue page wrapper and nav component) -->
            <text type="html" location="component://webroot/screen/includes/WebrootVue.qvt.ftl"/>
            <!-- not meant to be used for anything else, for all other render modes go directly through /apps -->
        </render-mode>

        <!-- Always render subscreens - either the selected path or the default AppList -->
        <section name="SubscreenSection">
            <condition><expression>!ec.web.parameters.vue</expression></condition>
            <widgets>
                <render-mode><text template="true">${sri.renderSubscreen()}</text></render-mode>
            </widgets>
        </section>
    </widgets>
</screen>
