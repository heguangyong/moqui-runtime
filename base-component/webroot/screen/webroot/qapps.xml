<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<screen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/xml-screen-3.xsd"
        require-authentication="false" screen-theme-type-enum-id="STT_INTERNAL_QUASAR" default-menu-title="Applications" allow-extra-path="true">
    <!-- NOTE: require-authentication=false so no permission required but in pre-actions if no user logged in goes to login screen -->

    <pre-actions><script><![CDATA[
        // 纯JWT认证系统 - 完全符合用户"只能用jwt这套东西"要求

        // Check if accessing marketplace Chat
        def currentPath = sri.getScreenUrlInfo().getFullPathNameList().join("/")
        def isMarketplaceChat = currentPath?.contains("marketplace/Chat")

        // 纯JWT认证：优先使用现有session，其次验证JWT
        def isAuthenticated = ec.user.userId ? true : false

        def authHeader = ec.web.getRequest().getHeader('Authorization')
        def jwtToken = null

        if (authHeader?.startsWith('Bearer ')) {
            jwtToken = authHeader.substring(7)  // Remove "Bearer " prefix
        } else {
            // 检查cookie中的JWT token
            def jwtCookie = ec.web.getRequest().getCookies()?.find { it.name == 'jwt_access_token' }
            if (jwtCookie?.value?.startsWith('eyJ')) {  // JWT format check
                jwtToken = jwtCookie.value
            }
        }

        if (jwtToken) {
            logger.debug("JWT认证：检测到token，length=${jwtToken.length()}, session userId=${ec.user.userId}")
            try {
                // 基础JWT验证：检查格式和过期时间
                def parts = jwtToken.split('\\.')
                if (parts.length == 3) {
                    def payload = new String(java.util.Base64.getDecoder().decode(parts[1]))
                    def payloadJson = new groovy.json.JsonSlurper().parseText(payload)

                    def now = System.currentTimeMillis() / 1000
                    if (payloadJson.exp && payloadJson.exp > now) {
                        def userId = payloadJson.userId ?: payloadJson.sub
                        logger.debug("JWT认证：解析payload userId=${userId}, exp=${payloadJson.exp}, now=${now}")
                        if (userId && userId.length() > 0) {
                            try {
                                if (ec.user.userId != userId) {
                                    def userAccount = ec.entity.find("moqui.security.UserAccount")
                                            .condition("userId", userId)
                                            .disableAuthz()
                                            .one()
                                    if (userAccount?.username) {
                                        logger.debug("JWT认证：internalLoginUser(${userAccount.username})")
                                        ec.user.internalLoginUser(userAccount.username)
                                    } else {
                                        throw new IllegalStateException("无法根据userId ${userId} 找到有效的UserAccount")
                                    }
                                }
                                isAuthenticated = true
                                logger.info("纯JWT认证成功: ${userId}")
                            } catch (Exception loginEx) {
                                logger.warn("JWT用户登录失败: ${loginEx.message}", loginEx)
                            }
                        }
                    } else {
                        logger.warn("JWT token已过期 exp=${payloadJson.exp} now=${now}")
                    }
                } else {
                    logger.warn("JWT token结构不正确，parts=${parts.length}")
                }
            } catch (Exception e) {
                logger.warn("JWT验证异常: ${e.message}", e)
            }
        } else if (!isAuthenticated) {
            logger.debug("JWT认证：未检测到token, session userId=${ec.user.userId}")
        }

        // 开发调试：强制跳过认证检查用于测试
        def skipAuth = (ec.web.getRequest().getParameter('skipAuth') == 'true')

        logger.debug("JWT认证：结果 isAuthenticated=${isAuthenticated}, isMarketplaceChat=${isMarketplaceChat}, skipAuth=${skipAuth}, currentPath=${currentPath}, session userId=${ec.user.userId}")

        // if authentication failed and not marketplace Chat, redirect to Login
        if (!isAuthenticated && !isMarketplaceChat && !skipAuth) {
            logger.info("JWT认证：未通过，重定向至 /Login (path=${currentPath})")
            ec.web.saveScreenLastInfo(null, null);
            sri.sendRedirectAndStopRender('/Login')
        }

        html_scripts.add('/libs/moment.js/moment-with-locales.min.js')
        html_scripts.add('/libs/jquery/jquery.min.js')
        html_scripts.add('/includes/JwtAuth.js')

        // For marketplace Chat, pre-load the styles and LiveChat script
        if (isMarketplaceChat) {
            // Add marketplace chat specific styles without Bootstrap dependencies
            html_stylesheets.add('/css/marketplace-chat.css')

            // Add LiveChat and marketplace chat scripts to footer
            footer_scripts.add('http://localhost:4000/livechat/rocketchat-livechat.min.js')
            footer_scripts.add('/js/marketplace-chat-livechat.js')
        }

        String instancePurpose = System.getProperty("instance_purpose")
        String quasarCss = sri.buildUrl('/libs/quasar2/quasar.min.css').url
        if (!html_stylesheets.contains(quasarCss)) html_stylesheets.add(quasarCss)
                if (!instancePurpose || instancePurpose == 'production') {
            /* ========== Production Mode - Vue 3.x + Quasar 2.x ========== */
            html_scripts.add('/js/MoquiLib.min.js')
            footer_scripts.add('/libs/vue3/vue.min.js')
            footer_scripts.add('/libs/quasar2/quasar.umd.min.js')
            footer_scripts.add('/js/WebrootVue.qvt.js')
        } else {
            /* ========== Dev Mode - Vue 3.x + Quasar 2.x ========== */
            html_scripts.add('/js/MoquiLib.js')
            footer_scripts.add('/libs/vue3/vue.js')
            footer_scripts.add('/libs/quasar2/quasar.umd.js')
            footer_scripts.add('/js/WebrootVue.qvt.js')
        }

        // conditional QZ Tray scripts, only include if enabled
        if (ec.user.getPreference("qz.print.enabled") == "true") {
            footer_scripts.add('/js/qz-tray/sha-256.min.js')
            footer_scripts.add('/js/qz-tray/qz-tray.min.js')
            // TODO migrate MoquiQzComponent.js to MoquiQzComponent.qvt.js
            footer_scripts.add('/js/qz-tray/MoquiQzComponent.js')
        }
    ]]></script></pre-actions>

    <transition name="setPreference">
        <actions><script>
            // 检查用户是否已登录
            if (!ec.user.userId) {
                ec.web.response.sendError(401, "User not logged in")
                return
            }

            // 检查参数
            if (!preferenceKey) {
                ec.web.response.sendError(400, "preferenceKey is required")
                return
            }

            try {
                ec.user.setPreference(preferenceKey, preferenceValue)
            } catch (Exception e) {
                logger.error("setPreference failed for key ${preferenceKey}", e)
                ec.web.response.sendError(500, "Failed to set preference: " + e.message)
            }
        </script></actions>
        <default-response type="none"/>
    </transition>

    <transition name="qzSign">
        <parameter name="message"/>
        <actions><script>
            import org.moqui.context.ExecutionContext
            ExecutionContext ec = context.ec
            ec.web.response.setContentType("text/plain")
            ec.web.response.writer.write("---...---")
        </script></actions>
        <default-response type="none"/>
    </transition>

    <transition name="getPreferences">
        <actions><script>
            import groovy.json.JsonBuilder
            def preferences = [:]
            preferences["qz.printer.main.active"] = ec.user.getPreference("qz.printer.main.active") ?: ""
            preferences["qz.printer.label.active"] = ec.user.getPreference("qz.printer.label.active") ?: ""
            ec.web.response.setContentType("application/json")
            ec.web.response.writer.write(new JsonBuilder(preferences).toString())
        </script></actions>
        <default-response type="none"/>
    </transition>

    <transition name="menuData" read-only="true" begin-transaction="false">
        <actions><script><![CDATA[
            // Get menu data for qapps navigation, always include homepage link at top
            List menuDataList = []

            // Add "返回主页" (Return to Homepage) link at the top
            menuDataList.add([
                title: "返回主页",
                url: "/qapps/AppList",
                image: "fa fa-home",
                imageType: "icon"
            ])

            // Determine which screen path to use when building the menu tree.
            // - Prefer explicit screenPath parameter (provided by SPA navigation)
            // - Fallback to current request's extra-path list (works for server-rendered paths)
            List<String> targetPathList = null
            String screenPathParam = ec.web.parameters.screenPath
            if (screenPathParam) {
                targetPathList = screenPathParam.split('/')*.trim().findAll { it }
            }
            if (!targetPathList || targetPathList.isEmpty()) {
                targetPathList = sri.screenUrlInfo.extraPathNameList
            }

            // Get standard menu data from screen
            List standardMenuList = sri.getMenuData(targetPathList)
            if (standardMenuList != null) {
                menuDataList.addAll(standardMenuList)
            }

            ec.web.sendJsonResponse(menuDataList)
        ]]></script></actions>
        <default-response type="none" save-parameters="true"/>
    </transition>

    <subscreens default-item="AppList">
        <subscreens-item name="AppList" location="component://webroot/screen/webroot/apps/AppList.xml"/>
        <subscreens-item name="tools" location="component://tools/screen/Tools.xml"/>
        <subscreens-item name="system" location="component://tools/screen/System.xml"/>
        <subscreens-item name="simple" location="component://SimpleScreens/screen/SimpleScreens.xml"/>
        <subscreens-item name="marketplace" location="component://moqui-marketplace/screen/marketplace.xml"/>
        <subscreens-item name="minio" location="component://moqui-minio/screen/MinioApp.xml"/>
        <subscreens-item name="hmadmin" location="component://HiveMind/screen/HiveMindAdmin.xml"/>
    </subscreens>

    <widgets>
        <render-mode>
            <!-- for html just render the navbar (Vue page wrapper and nav component) -->
            <text type="html" location="component://webroot/screen/includes/WebrootVue.qvt.ftl"/>
            <!-- not meant to be used for anything else, for all other render modes go directly through /apps -->
        </render-mode>

        <!-- Always render subscreens - either the selected path or the default AppList -->
        <section name="SubscreenSection">
            <widgets>
                <render-mode><text template="true">${sri.renderSubscreen()}</text></render-mode>
            </widgets>
        </section>
    </widgets>
</screen>
